  1. В каких городах больше одного аэропорта?
                                       
                                         
                                        
select city
from bookings.airports a         --в таблице Аэропорты посчитаем количество строк, сгруппированное по городам 
group by city                    --т.е.по каждому городу
having count(airport_code) > 1   --поставим фильтр на количество аэропортов в городе больше 1 
order by city                    --для удобства просмотра упорядочим по названиям городов в алфавитном порядке 

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

                                  2. В каких аэропортах есть рейсы, выполняемые самолетом с максимальной дальностью перелета? 
                                     !Использовать подзапрос. 
 
 --Порядок выполнения задачи:
 --1.Решаем подзадачу: выведем самолет из таблицы Самолеты, упорядочив модели по убыванию дальности и отсечем самую первую строку. Это и будет самый мощный самолет.  
 --2.Соединяем таблицу полетов (из предложения from) с аэропортами (в таблице полетов видим, что аэропорт отправления обозначен кодом аэропорта, это поле departure_airport) 
 --3.Соединяем полученные данные с самолетами,чтобы выбрать данные по соответствию кода самолета данным подзапроса (можно сравнивать в where с помощью знаков сравнения,т.к.
 --  подзапросом получили единственный код самолета)
 --4.Упорядочим по названию аэропорта в алфавитном порядке.
 --5.Для того,чтобы убрать дублирование строк, применим признак уникальности городов   
   
select distinct airport_name  --пункт 5
from bookings.flights f        
join bookings.airports a2 on f.departure_airport = a2.airport_code--пункт 2 
join bookings.aircrafts a3 using(aircraft_code)                   --пункт 3 
where aircraft_code = 
   (select a.aircraft_code     --пункт 1
	from bookings.aircrafts a      
	order by a."range" desc      
	limit 1) 
order by airport_name                  --пункт 4

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------                                
                                    
                                3. Вывести 10 рейсов с максимальным временем задержки вылета. 
                                   !Использовать Оператор limit.

 --Решение:
 --Время задержки вылета это разница между актуальным и планируемым временем вылета.Данные в формате timestamp, поэтому разница будет в виде интервала часы-минуты-секунды внутри даты
 --Проверять положительность такой разницы нет смысла,т.к.рейс не может вылететь раньше времени по расписанию. 
 --Данные о рейсах, фактическом и планируемом времени вылета/прилета находятся в таблице flights
 --В условии where нужно учесть, что работать нужно с вылетевшими самолетами на дату среза БД (статус Departed).
 --Упорядочим данные по убыванию времени задержки вылета.
 --Отсечем первые 10 строк.
    
select flight_no , actual_departure - scheduled_departure as delay 
from bookings.flights f 
where status = 'Departed'
order by delay desc 
limit 10

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

                              4.Были ли брони, по которым не были получены посадочные талоны? 
                                !Верный тип join

--Решение:
--Необходимо соединить таблицу bookings с boarding_passes.Напрямую они не связаны. Поэтому соединяем bookings с tickets по номеру бронирования.  
--Затем присоединяем вспомогательную таблицу ticket_flights по номеру билета.
--Найдем общие сущности таблицы boarding_passes и ticket_flights для присоединения: 
--Хотя в обеих таблицах и присутствует id полета,но в данном случае он нам не нужен,т.к.комбинация этого поля с id полета используется только для контроля правильности 
--распределения пассажиров по местам в самолете.
--Поэтому нас здесь будет интересовать только № билета, как общая сущность для этих двух таблиц. 
--Использовать будем left join, чтобы несовпадающие строки второй таблицы присоединились полностью.Несовпадающие с левой таблицей строки будут имеет тип null.
--Тогда мы сможем выбрать брони, у которых есть номер, но номер посадочного талона имеет тип null. Это и есть искомые данные. Уберем дублирующиеся по номеру брони строки с помощью 
--оператора distinct. 

select distinct b.book_ref
from bookings.bookings b 
left join bookings.tickets t on b.book_ref = t.book_ref 
left join bookings.ticket_flights tf on t.ticket_no = tf.ticket_no 
left join bookings.boarding_passes bp on tf.ticket_no = bp.ticket_no
where bp.boarding_no is null    

                            
                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

                              5.Найдите свободные места для каждого рейса, их % отношение к общему количеству мест в самолете.
                               Добавьте столбец с накопительным итогом - суммарное накопление количества вывезенных пассажиров из каждого аэропорта на каждый день.
                               Т.е. в этом столбце должна отражаться накопительная сумма - сколько человек уже вылетело из данного аэропорта на этом или более ранних рейсах за день.
                               !Обязательное условие- оконная функция
                                                    - подзапросы или/и cte.
                             
--1.Нам нужно соединить id рейса с самолетом и затем с кол-вом мест в этом самолете согласно модели.
--Так мы сможем вывести id рейса и кол-во мест в самолете на этом рейсе в принципе. Это будет первое СТЕ.
--2.Свободные места-это места, не занятые посадочными талонами. Нужно найти кол-во посадочных талонов на самолет согласно id рейса.Это будет второе СТЕ.
---Кол-во строк 11518,т.е.на какие-то рейсы талоны еще не выдавались.В первом СТЕ получили 33121 строки.
---Значит соединять будем второе сте с первым,т.к.нам нужно работать с рейсами,на которые выдавались талоны.Именно для них мы будем считать количество свободных мест и остальные показатели.                                                     
--3.Из сте2 соединенного с сте1 вывели id рейса, количество мест всего (для контроля расчетов),расчетную колонку кол-во мест в самолете минус кол-во выданных посадочных талонов,
  --и расчетную колонку процента свободных мест в самолете(привела все количества к типу numeric,чтобы получить дробное число, иначе нам выводился логично 0,как результат отбрасывания дроб.части при делении меньшего на большее.)
--4.Выведем дату вылета, аэропорт вылета и количество вывезенных пассажиров в этот день из этого аэропорта(проверить правильность накопления можно по занятым местам за день) 
--5.Применим оконную функцию-посчитаем по каждому аэропорту за каждый день кол-во вывелетевших пассажиров (накопление-с помощью order by по дате вылета)
  --Привели дату вылета к типу дата для того,чтобы вылеты в течение этого дня сгруппировались в одно количество.

with cte1 as   
	(select flight_id , count(s.seat_no) 
	from bookings.flights f 
	join bookings.aircrafts a on f.aircraft_code = a.aircraft_code 
	join bookings.seats s on a.aircraft_code = s.aircraft_code 
	group by flight_id 
	order by flight_id),
	cte2 as    
	(select flight_id , count(seat_no)            
	 from bookings.boarding_passes bp  
	 group by flight_id 
	 order by flight_id 
	)
select flight_id , 
      cte1.count as all_seats, 
      cte1.count-cte2.count as free_seats, 
      round(((cte1.count-cte2.count)::numeric) /cte1.count::numeric *100) as percent_free, 
      f2.departure_airport,--для контроля накопления по аэропортам
      f2.actual_departure,--для контроля накопления по дате вылета 
      sum(cte2.count) over (partition by f2.departure_airport,f2.actual_departure::date order by f2.actual_departure::date) as airport_one_day                                                                    
from cte2                                                                                                                                                       
join cte1 using(flight_id)
join bookings.flights f2 using (flight_id)
group by flight_id, cte1.count, cte1.count-cte2.count,cte2.count, f2.departure_airport , f2.actual_departure  


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                         
                              6. Найдите процентное соотношение перелетов по типам самолетов от общего количества.
                                 !Обязательное условие - подзапрос
                                                       - оператор ROUND
                                 
--1.Напишем подзапрос для нахождения общего количества самолетов по рейсам.Для этого таблицу рейсов нужно соединить с таблицей самолетов по коду самолета.
  --Получим 1 число, которое составляет 100%. На это количество будем делить количество типов летавших самолетов и умножим на 100.
--2.Поскольку результат деления целых чисел отбрасывает дробную часть и оставит только 0 целых,нужно привести к типу numeric
--3.Округлим результат деления с помощью оператора round.
--При проверке результата на сумму процентов получаем 101%. Плюс-минус 1% от 100% допустимо при округлении оператором ROUND.                                                        
                                                       
select f.aircraft_code,a.model ,
round(count(f.aircraft_code)::numeric / (select count(f.aircraft_code)::numeric from bookings.flights f)*100)                                 
from bookings.flights f 
join bookings.aircrafts a on f.aircraft_code = a.aircraft_code  
group by f.aircraft_code, a.model                                                       
                                                     
                                                 
                                
                                
                                
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
                              7. Были ли города, в которые можно  добраться бизнес - классом дешевле, чем эконом-классом в рамках перелета?
                                 !Обязательное условие - СТЕ.

--1.Необходимо разделить логику на нахождение цены в бизнес-классе и эконом-классе билетах на перелет в город прибытия.
  --1е сте: во from выводим таблицу ticket_flights,в которой есть стоимость билетов и класс обслуживания.                                 
    --      Для вывода города присоединим таблицу рейсов, затем таблицу аэропортов,чтобы вывести город аэропорта прибытия. Профильтруем в where по классу эконом.                  
  --2е сте: сделаем то же самое для класса бизнес 
--2.Теперь соединим оба сте по городу прибытия                                 
--3.Поставим условие : стоимость бизнес-класса меньше эконом
  --Оператор distinct применяем для группировки строк по городам. 
--4.Упорядочим по наименованию городов.

with cte1 as 
	(select distinct a.city , tf.amount as economy  
	 from bookings.ticket_flights tf
	 join bookings.flights f on tf.flight_id = f.flight_id
	 join bookings.airports a on f.arrival_airport = a.airport_code 
	 where fare_conditions = 'Economy'
	),
	cte2 as	
   (select distinct a.city , tf.amount as business  
	 from bookings.ticket_flights tf
	 join bookings.flights f on tf.flight_id = f.flight_id
	 join bookings.airports a on f.arrival_airport = a.airport_code 
	 where fare_conditions = 'Business'
   )
select distinct cte1.city
from cte1
join cte2 using(city)
where cte2.business < cte1.economy  
order by cte1.city 
                          
                               
                               
                                
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

                              8.Между какими городами нет прямых рейсов?
                                !Обязательное условие   - Декартово произведение в предложении from,
                                                        - Самостоятельно созданные представления, 
                                                        - Оператор  except
                                                        
--Найдем все возможные пары городов из таблицы Аэропорты,соединив декартовым произведением во from таблицу Аэропорты саму с собой.
--При этом необходимо поставить условие,что по строке города не должны быть одинаковы. Это будет первое представление (сохраненная логика) 
create view all_cities as
select a.city as departure_city , a2.city as arrival_city 
from bookings.airports a , bookings.airports a2 
where a.city != a2.city 

--Второе представление: соединим таблицу рейсов с аэропортами по коду аэропорта вылета, затем по коду аэропорта прибытия, а также с таблицей самолетов по коду самолета для полноты информации.
create view my_routes as
select distinct flight_no , a.city as departure_city, a.airport_name as departure_airport_name , a2.city as arrival_city, a2.airport_name as arrival_airport_name, a3.aircraft_code 
from bookings.flights f
join bookings.airports a on f.departure_airport = a.airport_code 
join bookings.airports a2 on f.arrival_airport = a2.airport_code 
join bookings.aircrafts a3 on f.aircraft_code = a3.aircraft_code 
order by 1

--Вычтем из всех возможных пар городов пары прямых рейсов с помощью оператора except
select departure_city, arrival_city 
from all_cities ac 
except 
select departure_city , arrival_city 
from my_routes 
order by 1, 2 



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

                               9. Вычислите расстояние между аэропортами, связанными прямыми рейсами, 
                                  сравните с допустимой максимальной дальностью перелетов  в самолетах, обслуживающих эти рейсы.                         
                                  !Обязательное условие - Оператор RADIANS или использование sind/cosd
                                                        - CASE 
Справочная информация:  
. В локальной базе координаты находятся в столбцах airports.longitude и airports.latitude.
Кратчайшее расстояние между двумя точками A и B на земной поверхности (если принять ее за сферу) определяется зависимостью:
d = arccos {sin(latitude_a)·sin(latitude_b) + cos(latitude_a)·cos(latitude_b)·cos(longitude_a - longitude_b)}, 
где latitude_a и latitude_b — широты, longitude_a, longitude_b — долготы данных пунктов, d — расстояние между пунктами измеряется в радианах длиной дуги большого круга земного шара.
Расстояние между пунктами, измеряемое в километрах, определяется по формуле:
L = d·R, где R = 6371 км — средний радиус земного шара.

--Прямые рейсы между аэропортами находятся в ранее созданном представлении в 8м задании- my_routes.
--Выводим из представления my_routes номер рейса для контроля данных, аэропорт вылета, аэропорт прилета.
--Соединяем с таблицей аэропортов по аэропорту вылета для того,чтобы проставить координаты аэропортов отправления.
--Соединяем  с таблицей аэропортов по аэропорту прибытия для того,чтобы проставить координаты аэропортов прилета.
--Выводим в select широту и долготу аэропорта вылета, широту и долготу аэропорта прилета.
--Выводим расчетный столбец по формуле расчета расстояния по координатам. При этом в свойствах таблицы аэропортов можно увидеть, что координаты имеют тип данных float.
--  Поэтому с помощью функции RADIANS приводим их в радианы, чтобы затем применить матем.функции sin и cos. Полученный результат округляем с помощью round.
--В вывод добавляем вывод значения по условию:
--   Если дальность самолета (range из таблицы самолетов) превышает значение в расчетном столбце-выводим "Самолет долетит". Иначе "Самолет не долетит"    

select flight_no , departure_airport_name , a.latitude , a.longitude , arrival_airport_name, a2.latitude , a2.longitude,
        round((acos(sin(radians(a.latitude))*sin(radians(a2.latitude)) + cos(radians(a.latitude))*cos(radians(a2.latitude))*cos(radians(a.longitude) - radians(a2.longitude)))) * 6371) as distance,--расчетный столбец расстояния между аэропортами
        m_r.aircraft_code,
case  
    when a3."range" > round((acos(sin(radians(a.latitude))*sin(radians(a2.latitude)) + cos(radians(a.latitude))*cos(radians(a2.latitude))*cos(radians(a.longitude) - radians(a2.longitude)))) * 6371)
    then 'Самолет долетит'
    else 'Самолет не долетит'
end    
from my_routes m_r                                                                                                                                                                             
join bookings.airports a on m_r.departure_airport_name = a.airport_name
join bookings.airports a2 on m_r.arrival_airport_name = a2.airport_name
join bookings.aircrafts a3 on m_r.aircraft_code = a3.aircraft_code 
